<?xml version="1.0" encoding="UTF-8"?>

<xsd:schema
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xmlns="FSMP-Validator"
	targetNamespace="FSMP-Validator"
	elementFormDefault="qualified"
    attributeFormDefault="unqualified"
	version="2.1.0"
	>

	<!-- ############################################################ -->
	<!-- attributeGroups -->
	<!-- ############################################################ -->

	<xsd:attributeGroup name="defaults">
        <xsd:attribute name="name" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation>
					The name of a bone-default or generic-constraint-default is optional. If it isn't set, "" is the name.
As the xml is interpreted line by line, you can redefine the default so that it impacts the following bones or generic-constraints.
                </xsd:documentation>
            </xsd:annotation>
			<!-- We could replace the type string by something more "ID"
			<xsd:simpleType>
				<xsd:restriction base="xsd:ID">
					<xsd:pattern value=".*" />
				</xsd:restriction>
			</xsd:simpleType>
			-->
        </xsd:attribute>
        <xsd:attribute name="extends" type="xsd:string" use="optional"/>
    </xsd:attributeGroup>

	<!-- ############################################################ -->
	<!-- simpleTypes -->
	<!-- ############################################################ -->

	<xsd:simpleType name="factor">
        <xsd:restriction base="xsd:float">
            <xsd:minInclusive value="0"/>
            <xsd:maxInclusive value="1"/>
        </xsd:restriction>
    </xsd:simpleType>
    <xsd:simpleType name="posFloat">
        <xsd:restriction base="xsd:float">
            <xsd:minInclusive value="0"/>
        </xsd:restriction>
    </xsd:simpleType>
	<xsd:simpleType name="shapeType">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="ref"/>
			<xsd:enumeration value="box"/>
			<xsd:enumeration value="sphere"/>
			<xsd:enumeration value="capsule"/>
			<xsd:enumeration value="hull"/>
			<xsd:enumeration value="cylinder"/>
			<xsd:enumeration value="compound"/>
		</xsd:restriction>
	</xsd:simpleType>

	<!-- ############################################################ -->
	<!-- simple elements -->
	<!-- ############################################################ -->

	<xsd:element name="angularBounce" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to (0.0, 0.0, 0.0).
Sets the bounce on the rotational limit motor on a generic 6 degrees of freedom constraint (Generic6DofSpring2Constraint).
Is used to calculate the bounce error, which is used to limit the constraint error.
It's the only use I saw in the code.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularDamping" type="factor">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Between 0 and 1, will be clamped. If undefined, it's set to 0.
				Sets the angularDamping on the btRigidBody of a bone.
				Each physics step, the damping is applied on the btRigidBody angular velocity with this formula:
				angularVelocity *= pow(1 - angularDamping, timeStep)
				Timestep is in seconds.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularEquilibrium" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to (0.0, 0.0, 0.0).
FSMP 1.x: sets the orientation of the equilibrium point of a generic 6 degrees of freedom constraint (Generic6DofSpring2Constraint).
The code existing in Bullet to calculate it automatically isn't used.
FSMP 2.x: maximum force to be applied to enabled angular motors.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularLowerLimit" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to (1,1,1) (sic!). Each axis is in radians, and will be translated towards [-Pi, Pi].
The Generic 6 Degrees of Freedom Spring 2 constraint contains a 3D vector of angular limits (Rotational Limit Motor 2),
and this sets the minimum radian value of the angular constraint.
Beware: lower limit being greater than upper limit is interpreted as no constraint.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularMaxMotorForce" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Vector3. Maximum force to be applied to enabled angular motors.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularMotors" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Enables motors for all three angular axes. Motors add force at a constant rate (can stabilise springs).
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularNonHookeanDamping" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Default: 0.
Applies a reduction or increase in spring damping, starting at 0 at equilibrium, and ending at factor * damping when at the limit.
At equilibrium, damping is unchanged.  A value of 0.5 means that by the time a spring is halfway from its resting point to the LowerLimit, it will have lost 0.25 * damping.
Positive values reduce damping, negative values increase it.
The useful range of this is typically -0.75 to 0.9, however values outside this are fine.
Pairs extremely well with angularNonHookeanStiffness.
damping * (1 - distanceFactor * angularNonHookeanDamping)
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularNonHookeanStiffness" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Default: 0.
Applies a reduction or increase in spring stiffness, starting at 0 at equilibrium, and ending at factor * stiffness when at the limit.
At equilibrium, stiffness is unchanged.  A value of 0.5 means that by the time a spring is halfway from its resting point to the LowerLimit, it will have lost 0.25 * stiffness.
Positive values reduce stiffness, negative values increase it.
The useful range of this is typically -0.75 to 0.9, however values outside this are fine.
Pairs extremely well with angularNonHookeanDamping.
stiffness * (1 - distanceFactor * angularNonHookeanStiffness)
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularOnly" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>FSMP 2.x: Optional. If undefined, it's set to false.</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularServoMotors" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Boolean. Default: false.
If true, any enabled angular motors will function as servo motors, allowing a specific target coordinate to be set per axis. Current impl. simply changes this to the equilibrium point.
Motors must be enabled (angularMotors).
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularSpringFrequency" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Float (0.0 - 1.0). Default 0.25. This is a flood control for angular calculation. Lower values place a cap on the stiffness of springs, but may increase FPS.
Use angularStiffnessLimited to remove the cap (do not set this to 1.0).
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularStiffness" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to (0,0,0).
				The Generic 6 Degrees of Freedom Spring 2 constraint contains a 3D vector of angular limits (Rotational Limit Motor 2),
				and this sets the spring stiffness of the angular constraint.
				This stiffness will be dynamically limited: "the spring should not be sampled faster that the quarter of its angular frequency"
				max stiffness = mass / (16 * dt * dt) (dt being the timestep)
				What sets the direction of the new velocity is the sign of:
				stiffness * distance from the equilibrium point - damping * velocity.
				NB: damping is dynamically limited too: max damping = m / dt
				Quick way to define it: mass * 40 * (turns per second) * (turns per second)
				Here is the explanation: angular stiffness = mass * (angular frequency)^2 = mass * 4 * Pi^2 * (turns per second)^2
				For example, if you have a mass of 1 kg, and you want it to oscillate around the x axis 2 times per second, you'll have::
				(1 * 4 * Pi^2 * 2^2, , ) = (157.91, , )
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularStiffnessLimited" type="xsd:boolean">
        <xsd:annotation>
            <xsd:documentation>
                FSMP 2.x: Optional. If undefined, it's set to true.
				Limits the spring frequency to max 0.25 turns per timestep.
				Honestly, you should set it to false and set your stiffness at the right level, because this limit is way too high:
				when you attain it, the spring will oscillate around once every 4 frames, you will perceive incredible jittering!
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="springDampingLimited" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. If undefined, it's set to true.
				Limits the spring damping to mass x fps. This doesn't work for elements which could be scaled (like a body) because changing the scale changes the mass.
				You should set it to false.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularTargetVelocity" type="vector3">
		<xsd:annotation>
			<xsd:documentation>FSMP 2.x: Optional. Vector3. Target velocity of angular motors.</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="angularUpperLimit" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to (-1,-1,-1) (sic!). Each axis is in radians, and will be translated towards [-Pi, Pi].
The Generic 6 Degrees of Freedom Spring 2 constraint contains a 3D vector of angular limits (Rotational Limit Motor 2),
and this sets the maximum radian value of the angular constraint.
Beware: lower limit being greater than upper limit is interpreted as no constraint.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="biasFactor" type="factor">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Between 0 and 1. If undefined, it's set to 0.3.
Bullet recommendation: between 0 and 0.6.
This is the strength with which a constraint resists zeroth order (angular, not angular velocity) limit violation.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="can-collide-with-bone" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
				Optional. Bone name.
				IMPORTANT: the setting can-collide-with-bone will override any configuration of can/no-collide-with-tag.
				When you set this value, you are saying "collide with the bones I list, and literally nothing else".
				It is useless to use no-collide-with-bone and can-collide-with-bone in the same shape.
				If both are used, only can-collide-with-bone will be used. If none are used, collisions work.
				Mnemotechnic tip: can > no.
			</xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="can-collide-with-tag" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				It is useless to use no-collide-with-tag and can-collide-with-tag in the same shape.
				If both are used, only can-collide-with-tag will be used. If none are used, collisions work.
				Mnemotechnic tip: can > no.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="centerOfMassTransform" type="transform">
        <xsd:annotation>
            <xsd:documentation>
                Optional. Default: Basis: 0,0,0,1, Origin: 0,0,0.
This will offset the rotation (basis, angular) or translation (origin, linear) centre of mass for this bone.
The impact of this is most evident on inertia (so, you definitely should go run around in circles and test your changes look okay. Seriously.).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="collision-filter" type="xsd:int">
        <xsd:annotation>
            <xsd:documentation>
                Optional. Default 0.
Currently unused in FSMP and Bullet.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="coneLimit" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the limitZ and swingSpan1 parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="damping" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Used to calculate damping in springstiff scale constraints, spring force in springstiff constraints, and the velocity error in constraints groups.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="disable-priority" type="xsd:int"/>
	<xsd:element name="disable-tag" type="xsd:string"/>
    <xsd:element name="enableAngularSprings" type="xsd:boolean">
        <xsd:annotation>
            <xsd:documentation>
                FSMP 2.x: Optional. Boolean. Default: true. Set to false to disable the spring entirely (also improves performance).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="enableLinearSprings" type="xsd:boolean">
        <xsd:annotation>
            <xsd:documentation>
				FSMP 2.x: Optional. Boolean. Default: true. Set to false to disable the spring entirely (also improves performance).
			</xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="equilibrium" type="factor">
		<xsd:annotation>
			<xsd:documentation>Optional. Between 0 and 1. If undefined, it's set to 0.5.
Allows to calculate, linearly between the minDistance and the maxDistance, the equilibrium point between 2 bodies in a StiffSpring constraint.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="frameInA" type="transform"/>
	<xsd:element name="frameInB" type="transform">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to Identity (no rotation, no translation):
basis x="0" y="0" z="0" w="1"
origin x="0" y="0" z="0"
			</xsd:documentation>
		</xsd:annotation>

	</xsd:element>
	<xsd:element name="frameInLerp" type="lerp"/>
	<xsd:element name="friction" type="xsd:float">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to 0.5.
Allows to calculate rolling friction, spinning friction and combined friction between 2 bodies.
Recommended: best simulation results happen when friction is non-zero (from the authors of the physics library).
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="gravity-factor" type="factor">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Between 0 and 1. If undefined, it's set to 1.
Will be applied to the gravity of the bone. Has no effect on a static or kinematic object (so no effect if the bone mass is zero).
Recommended: 1
Generally, doubling the gravity or doubling the mass gives exactly the same result, so you should configure mass rather than on gravity.
However, some functions (for example limitation of stiffness) use the mass without taking into account the gravity.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="half-extend" type="vector3"/>
	<xsd:element name="inertia" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Inverse factor. If undefined it's set to 0 (and no inertia is calculated).
Local inertia is divided by this number, resulting in rather peculiar, extremely unphysicsy behaviour.
Below one to increase, above one to decrease.
When set to zero, the local insertia isn't considered infinite, but zero.
Recommended (strongly!): 1
			</xsd:documentation>
		</xsd:annotation>
    </xsd:element>
	<xsd:element name="limitSoftness" type="factor">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Between 0 and 1. If undefined, it's set to 1.
Bullet recommendations: between 0.8 and 1.
This describes the % of limits where the movement is free.
Beyond this softness %, the limit is gradually enforced until the "hard" (1.0) limit is reached.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="limitX" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the twistLimit and twistSpan parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="limitY" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the planeLimit and swingSpan2 parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="limitZ" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the coneLimit and swingSpan1 parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="linearBounce" type="vector3">
        <xsd:annotation>
            <xsd:documentation>
				Nope. Just don't.
				Optional. If undefined, it's set to (0.0, 0.0, 0.0).
			</xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="linearDamping" type="factor">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Between 0 and 1. If undefined, it's set to 0.
				On generic and stiffspring constraints, this is Hookean spring damping (good). On bones, this is a correction/adjustment (bad).
				Recommended (bones): 0
				Recommended (constraints): whatever damps your springs at the right rate.
				On bones: bone_linearVelocity *= (1 - bone_linearDamping)^timeStep
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="linearEquilibrium" type="vector3"/>
	<xsd:element name="linearLowerLimit" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to (1, 1, 1).
				Isn't applied if linearLowerLimit > linearUpperLimit.
				The displacement is limited to this value.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="linearNonHookeanDamping" type="vector3">
        <xsd:annotation>
            <xsd:documentation>
                FSMP 2.x: Optional. Default: 0.
Applies a reduction or increase in spring damping, starting at 0 at equilibrium, and ending at factor * damping when at the limit.
At equilibrium, damping is unchanged.
A value of 0.5 means that by the time a spring is halfway from its resting point to the LowerLimit, it will have lost 0.25 * damping.
Positive values reduce damping, negative values increase it.
The useful range of this is typically -0.75 to 0.9, however values outside this are fine.
Pairs extremely well with linearNonHookeanStiffness.
damping * (1 - distanceFactor * linearNonHookeanDamping)
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="linearNonHookeanStiffness" type="vector3">
        <xsd:annotation>
            <xsd:documentation>
                FSMP 2.x: Optional. Default: 0.
Applies a reduction or increase in spring stiffness, starting at 0 at equilibrium, and ending at factor * stiffness when at the limit.
At equilibrium, stiffness is unchanged.  A value of 0.5 means that by the time a spring is halfway from its resting point to the LowerLimit, it will have lost 0.25 * stiffness.
Positive values reduce stiffness, negative values increase it.
The useful range of this is typically -0.75 to 0.9, however values outside this are fine.
Pairs extremely well with angularNonHookeanDamping.
stiffness * (1 - distanceFactor * angularNonHookeanStiffness)
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="linearMaxMotorForce" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Vector3. Maximum force to be applied to enabled linear motors.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="linearMotors" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Enables motors for all three linear axes. Motors add force at a constant rate (can stabilise springs).
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="linearServoMotors" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Boolean. Default: false.
If true, any enabled linear motors will function as servo motors, allowing a specific target coordinate to be set per axis. The current implementation simply changes this to the equilibrium point.
Motors must be enabled (linearMotors).
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="linearSpringFrequency" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				FSMP 2.x: Optional. Float (0.0 - 1.0). Default 0.25. This is a flood control for angular calculation. Lower values place a cap on the stiffness of springs, but may increase FPS. Use linearStiffnessLimited to remove the cap (do not set this to 1.0).
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="linearStiffness" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Default (0, 0, 0).
				Here is a simple way to define it: linear stiffness = mass * (angular frequency)^2 = mass * 4 * Pi^2 * (turns per second)^2
				For example, if you have a mass of 1 kg, and you want it to oscillate along the x axis 2 times per second, you'll have:
				(1 * 4 * Pi^2 * 2^2, , ) = (157.91, , )
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="linearStiffnessLimited" type="xsd:boolean">
        <xsd:annotation>
            <xsd:documentation>
				FSMP 2.x: Optional. If undefined, it's set to true.
				Limits the spring frequency to max 0.25 turns per timestep.
				Honestly, you should set it to false and set your stiffness at the right level, because this limit is way too high:
				when you attain it, the spring will oscillate around once every 4 frames, you will perceive incredible jittering!
			</xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="linearTargetVelocity" type="vector3">
        <xsd:annotation>
            <xsd:documentation>
				FSMP 2.x: Optional. Vector3. Target velocity of linear motors.
			</xsd:documentation>
        </xsd:annotation>
    </xsd:element>
	<xsd:element name="linearUpperLimit" type="vector3">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to (-1, -1, -1).
				Isn't applied if linearLowerLimit > linearUpperLimit.
				The displacement is limited to this value. 
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="margin" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 1.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="margin-multiplier" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 1.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="mass" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive.
Setting mass to zero or unset creates a fixed (non-dynamic) rigid body.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="maxDistanceFactor" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 1.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="minDistanceFactor" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 1.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="motorCFM" type="xsd:float">
		<xsd:annotation>
			<xsd:documentation>FSMP 2.x: Optional. Default 0. Soft constraints are made with this. See ODE documentation for ERP/CFM.</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="motorERP" type="factor">
		<xsd:annotation>
			<xsd:documentation>FSMP 2.x: Optional. Default 0.9. See ODE documentation for ERP/CFM.</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="no-collide-with-bone" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				It is useless to use no-collide-with-bone and can-collide-with-bone in the same shape.
				If both are used, only can-collide-with-bone will be used. If none are used, collisions work.
				Mnemotechnic tip: can > no.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="no-collide-with-tag" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				It is useless to use no-collide-with-tag and can-collide-with-tag in the same shape.
				If both are used, only can-collide-with-tag will be used. If none are used, collisions work.
				Mnemotechnic tip: can > no.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="penetration">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to 1. Can be positive or negative.
Day's comment: I'm not sure a negative penetration works exactly as the inverse of a positive in the CUDA code...
			</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleType>
			<xsd:restriction base="xsd:float"/>
		</xsd:simpleType>
	</xsd:element>
	<xsd:element name="planeLimit" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the limitY and swingSpan2 parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="point" type="vector3"/>
	<xsd:element name="prenetration" type="xsd:float">
		<xsd:annotation>
			<xsd:documentation>
				Strictly equivalent to penetration. Use penetration.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="relaxationFactor" type="factor">
		<xsd:annotation>
			<xsd:documentation>Optional. Between 0 and 1. If undefined, it's set to 1.</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="restitution">
		<xsd:annotation>
			<xsd:documentation>Optional. If undefined, it's set to 0.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleType>
			<xsd:restriction base="xsd:float"/>
		</xsd:simpleType>
	</xsd:element>
	<xsd:element name="rollingFriction">
		<xsd:annotation>
			<xsd:documentation>Optional. If undefined, it's set to 0.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleType>
			<xsd:restriction base="xsd:float"/>
		</xsd:simpleType>
	</xsd:element>
	<xsd:element name="shared">
		<xsd:annotation>
			<xsd:documentation>Optional. Case-sensitive. If undefined or mistyped, it's set to "public". Valid options:
"public": the shape can collide with a body B if the shape's body can collide with that body B. Webspam phrasing: "Shape can match collisions anywhere, including other XML files on other skeletons."
"internal": the shape can't collide with a shape from another skeleton; if it's the same skeleton, then see "public". Webspam phrasing: "Shape can be referenced by any XML file, but only on this skeleton."
"external": the shape can't collide with a shape from the same skeleton; if it's another skeleton, then see "public". Webspam phrasing: "Shape can be referenced by any XML file, but only on other skeletons."
"private": the shape can't collide with another mesh; if it's the same mesh, then see "public". Webspam phrasing: "Shape can only be referenced within this file."
			</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleType>
			<xsd:restriction base="xsd:string">
				<xsd:enumeration value="public"/>
				<xsd:enumeration value="private"/>
				<xsd:enumeration value="internal"/>
				<xsd:enumeration value="external"/>
			</xsd:restriction>
		</xsd:simpleType>
	</xsd:element>
	<xsd:element name="stiffness" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="stopCFM" type="xsd:float">
		<xsd:annotation>
			<xsd:documentation>FSMP 2.x: Optional. Default 0. Soft constraints are made with this. See ODE documentation for ERP/CFM.</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="stopERP" type="factor">
		<xsd:annotation>
			<xsd:documentation>FSMP 2.x: Optional. Default 0.2. See ODE documentation for ERP/CFM. http://ode.org/wiki/index.php/Manual#Joint_error_and_the_Error_Reduction_Parameter_.28ERP.29</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="swingSpan1" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the coneLimit and limitZ parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="swingSpan2" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the limitY and planeLimit parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="tag" type="xsd:string">
		<xsd:annotation>
			<xsd:documentation>
				Optional.  String.
Once configured, a tag string can be used by other shapes to reference the shape, e.g. inside `can-collide-with-tag`, or `no-collide-with-tag` references.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="transform" type="transform"/>
	<xsd:element name="twistLimit" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the limitX and twistSpan parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="twistSpan" type="posFloat">
		<xsd:annotation>
			<xsd:documentation>
				Optional. Positive. If undefined, it's set to 0.
Strictly equivalent to the twistLimit and limitX parameters.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="useLinearReferenceFrameA" type="xsd:boolean">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to false.
If false, the constraint will be set between BodyA, BodyB, FrameA, FrameB.
If true, the constraint will be set between BodyB, BodyA, FrameB, FrameA.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
	<xsd:element name="weight-threshold">
		<xsd:annotation>
			<xsd:documentation>A "weight-threshold" in a "per-vertex-shape" or "per-triangle-shape" contains a float value and a "bone" attribute. Each skinned bone with that name in the "per-XXX-shape" has its weight-threshold set to the float value. This weight-threshold is used 3 ways:
- When preparing collisions, no collision effect (displacement) is considered if the weight of the bone is zero or lower than the weight-threshold.
- When processing collisions, when a collision happen between 2 shapes, if the weight of the shape at the vertex or triangle collision point is lower than the weight-threshold defined for the vertex or triangle collision point bone, then the collision effects aren't applied.
- In the CUDA version, the bone weight provided to the CUDA processor is the bone weight-threshold.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:simpleContent>
				<xsd:extension base="xsd:float">
					<xsd:attribute name="bone" type="xsd:string" use="required"/>
				</xsd:extension>
			</xsd:simpleContent>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="wind-effect" type="xsd:float">
		<xsd:annotation>
			<xsd:documentation>
				Optional. If undefined, it's set to 0.
Currently unused.
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>

	<!-- ############################################################ -->
	<!-- Complex elements -->
	<!-- ############################################################ -->

	<xsd:element name="bone-default">
		<xsd:complexType>
			<xsd:all>
				<xsd:element ref="mass" minOccurs="0"/>
				<xsd:element ref="inertia" minOccurs="0"/>
				<xsd:element ref="centerOfMassTransform" minOccurs="0"/>
				<xsd:element ref="linearDamping" minOccurs="0"/>
				<xsd:element ref="angularDamping" minOccurs="0"/>
				<xsd:element ref="gravity-factor" minOccurs="0"/>
				<xsd:element ref="friction" minOccurs="0"/>
				<xsd:element ref="rollingFriction" minOccurs="0"/>
				<xsd:element ref="restitution" minOccurs="0"/>
				<xsd:element ref="margin-multiplier" minOccurs="0"/>
				<xsd:element ref="shape" minOccurs="0"/>
				<xsd:element ref="collision-filter" minOccurs="0"/>
				<xsd:element ref="can-collide-with-bone" minOccurs="0"/>
				<xsd:element ref="no-collide-with-bone" minOccurs="0"/>
			</xsd:all>
			<xsd:attributeGroup ref="defaults" />
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="bone">
		<xsd:annotation>
			<xsd:documentation>
				Bones can be used in constraints tags, can-collide-with-bone tags and no-collide-with-bone tags without being declared in a bone tag.
				If a node with that name exists, a bone will be created on the fly with the current bone-default values.
				Beware: bones can be created only once; the second declaration won't be taken into account, and will issue a warning in hdtSMP64.log saying that the bone is skipped.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:all>
				<xsd:element ref="mass" minOccurs="0"/>
				<xsd:element ref="inertia" minOccurs="0"/>
				<xsd:element ref="centerOfMassTransform" minOccurs="0"/>
				<xsd:element ref="linearDamping" minOccurs="0"/>
				<xsd:element ref="angularDamping" minOccurs="0"/>
				<xsd:element ref="gravity-factor" minOccurs="0"/>
				<xsd:element ref="friction" minOccurs="0"/>
				<xsd:element ref="rollingFriction" minOccurs="0"/>
				<xsd:element ref="restitution" minOccurs="0"/>
				<xsd:element ref="margin-multiplier" minOccurs="0"/>
				<xsd:element ref="shape" minOccurs="0"/>
				<xsd:element ref="collision-filter" minOccurs="0"/>
				<xsd:element ref="can-collide-with-bone" minOccurs="0"/>
				<xsd:element ref="no-collide-with-bone" minOccurs="0"/>
			</xsd:all>
			<xsd:attribute name="name" type="xsd:string" use="required"/>
			<xsd:attribute name="template" type="xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="child">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="transform"/>
				<xsd:element ref="shape"/>
			</xsd:choice>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="conetwist-constraint">
		<xsd:annotation>
			<xsd:documentation>Don't use conetwist constraints. Anything you can do with a conetwist, you can do better with a GenericConstraint.
swingSpan1, coneLimit, limitX are strictly equivalent. You should declare only one of them.
swingSpan2, planeLimit, limitY are strictly equivalent. You should declare only one of them.
twistSpan, twistLimit, limitZ are strictly equivalent. You should declare only one of them.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="frameInA"/>
				<xsd:element ref="frameInB"/>
				<xsd:element ref="frameInLerp"/>
				<xsd:element ref="angularOnly"/>
				<xsd:element ref="swingSpan1"/>
				<xsd:element ref="swingSpan2"/>
				<xsd:element ref="twistSpan"/>
				<xsd:element ref="coneLimit"/>
				<xsd:element ref="planeLimit"/>
				<xsd:element ref="twistLimit"/>
				<xsd:element ref="limitX"/>
				<xsd:element ref="limitY"/>
				<xsd:element ref="limitZ"/>
				<xsd:element ref="limitSoftness"/>
				<xsd:element ref="biasFactor"/>
				<xsd:element ref="relaxationFactor"/>
			</xsd:choice>
			<xsd:attribute name="bodyA" type="xsd:string" use="required">
				<xsd:annotation>
					<xsd:documentation>
						bodyA is required and must contain a bone name. Bone declaration is optional, see the bone documentation.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="bodyB" type="xsd:string" use="required">
				<xsd:annotation>
					<xsd:documentation>
						bodyB is required and must contain a bone name. Bone declaration is optional, see the bone documentation.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="template" type="xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="conetwist-constraint-default">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="frameInA"/>
				<xsd:element ref="frameInB"/>
				<xsd:element ref="frameInLerp"/>
				<xsd:element ref="angularOnly"/>
				<xsd:element ref="swingSpan1"/>
				<xsd:element ref="swingSpan2"/>
				<xsd:element ref="twistSpan"/>
				<xsd:element ref="coneLimit"/>
				<xsd:element ref="planeLimit"/>
				<xsd:element ref="twistLimit"/>
				<xsd:element ref="limitX"/>
				<xsd:element ref="limitY"/>
				<xsd:element ref="limitZ"/>
				<xsd:element ref="limitSoftness"/>
				<xsd:element ref="biasFactor"/>
				<xsd:element ref="relaxationFactor"/>
			</xsd:choice>
			<xsd:attribute name="name" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>Don't use conetwist constraints. Anything you can do with a conetwist, you can do better with a GenericConstraint.
The name of a conetwist-constraint-default is optional. If it isn't set, "" is the name.
As the xml is interpreted line by line, you can redefine the default so that it impacts the following conetwist-constraints.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="extends" type="xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="constraint-group">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="generic-constraint"/>
				<xsd:element ref="generic-constraint-default"/>
				<xsd:element ref="stiffspring-constraint"/>
				<xsd:element ref="stiffspring-constraint-default"/>
				<xsd:element ref="conetwist-constraint"/>
				<xsd:element ref="conetwist-constraint-default"/>
			</xsd:choice>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="generic-constraint">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="angularBounce"/>
				<xsd:element ref="angularEquilibrium"/>
				<xsd:element ref="angularLowerLimit"/>
				<xsd:element ref="angularStiffness"/>
				<xsd:element ref="angularUpperLimit"/>
				<xsd:element ref="frameInA"/>
				<xsd:element ref="frameInB"/>
				<xsd:element ref="frameInLerp"/>
				<xsd:element ref="linearBounce"/>
				<xsd:element ref="linearEquilibrium"/>
				<xsd:element ref="linearLowerLimit"/>
				<xsd:element ref="linearStiffness"/>
				<xsd:element ref="linearUpperLimit"/>
				<xsd:element ref="linearSpringFrequency"/>
				<xsd:element ref="angularSpringFrequency"/>
				<xsd:element ref="linearStiffnessLimited"/>
				<xsd:element ref="angularStiffnessLimited"/>
				<xsd:element ref="enableLinearSprings"/>
				<xsd:element ref="enableAngularSprings"/>
				<xsd:element ref="linearMotors"/>
				<xsd:element ref="angularMotors"/>
				<xsd:element ref="linearServoMotors"/>
				<xsd:element ref="angularServoMotors"/>
				<xsd:element ref="linearTargetVelocity"/>
				<xsd:element ref="angularTargetVelocity"/>
				<xsd:element ref="linearMaxMotorForce"/>
				<xsd:element ref="angularMaxMotorForce"/>
				<xsd:element ref="linearNonHookeanDamping"/>
				<xsd:element ref="angularNonHookeanDamping"/>
				<xsd:element ref="linearNonHookeanStiffness"/>
				<xsd:element ref="angularNonHookeanStiffness"/>
				<xsd:element ref="useLinearReferenceFrameA"/>
				<xsd:element ref="stopERP"/>
				<xsd:element ref="stopCFM"/>
				<xsd:element ref="motorERP"/>
				<xsd:element ref="motorCFM"/>
				<xsd:element ref="springDampingLimited"/>
				<!-- linear and angular damping are already declared as floats for bones -->
				<!-- Yes, but they're crap and bad. This is spring damping. -->
				<xsd:element name="linearDamping" type="vector3"/>
				<xsd:element name="angularDamping" type="vector3"/>
			</xsd:choice>
			<xsd:attribute name="bodyA" type="xsd:string" use="required">
				<xsd:annotation>
					<xsd:documentation>
						bodyA is required and must contain a bone name. Bone declaration is optional, see the bone documentation.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="bodyB" type="xsd:string" use="required">
				<xsd:annotation>
					<xsd:documentation>
						bodyB is required and must contain a bone name. Bone declaration is optional, see the bone documentation.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="template" type="xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="generic-constraint-default">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="angularBounce"/>
				<xsd:element ref="angularEquilibrium"/>
				<xsd:element ref="angularLowerLimit"/>
				<xsd:element ref="angularUpperLimit"/>
				<xsd:element ref="angularStiffness"/>
				<xsd:element ref="frameInA"/>
				<xsd:element ref="frameInB"/>
				<xsd:element ref="frameInLerp"/>
				<xsd:element ref="linearBounce"/>
				<xsd:element ref="linearEquilibrium"/>
				<xsd:element ref="linearLowerLimit"/>
				<xsd:element ref="linearUpperLimit"/>
				<xsd:element ref="linearStiffness"/>
				<xsd:element ref="linearSpringFrequency"/>
				<xsd:element ref="angularSpringFrequency"/>
				<xsd:element ref="linearStiffnessLimited"/>
				<xsd:element ref="angularStiffnessLimited"/>
				<xsd:element ref="enableLinearSprings"/>
				<xsd:element ref="enableAngularSprings"/>
				<xsd:element ref="linearMotors"/>
				<xsd:element ref="angularMotors"/>
				<xsd:element ref="linearServoMotors"/>
				<xsd:element ref="angularServoMotors"/>
				<xsd:element ref="linearTargetVelocity"/>
				<xsd:element ref="angularTargetVelocity"/>
				<xsd:element ref="linearMaxMotorForce"/>
				<xsd:element ref="angularMaxMotorForce"/>
				<xsd:element ref="linearNonHookeanDamping"/>
				<xsd:element ref="angularNonHookeanDamping"/>
				<xsd:element ref="linearNonHookeanStiffness"/>
				<xsd:element ref="angularNonHookeanStiffness"/>
				<xsd:element ref="useLinearReferenceFrameA"/>
				<xsd:element ref="stopERP"/>
				<xsd:element ref="stopCFM"/>
				<xsd:element ref="motorERP"/>
				<xsd:element ref="motorCFM"/>
				<xsd:element ref="springDampingLimited"/>
				<!-- linear and angular damping are already declared as floats for bones -->
                <!-- Yes, but they're crap and bad.  This is spring damping. -->
				<xsd:element name="angularDamping" type="vector3"/>
				<xsd:element name="linearDamping" type="vector3"/>
			</xsd:choice>
            <xsd:attributeGroup ref="defaults" />
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="per-triangle-shape">
		<xsd:complexType>
			<xsd:choice maxOccurs="unbounded">
				<xsd:element ref="margin"/>
				<xsd:element ref="prenetration"/>
				<xsd:element ref="penetration"/>
				<xsd:element ref="tag"/>
				<xsd:element ref="shared"/>
				<xsd:element ref="no-collide-with-tag"/>
				<xsd:element ref="no-collide-with-bone"/>
				<xsd:element ref="can-collide-with-tag"/>
				<xsd:element ref="can-collide-with-bone"/>
				<xsd:element ref="weight-threshold"/>
				<xsd:element ref="disable-tag"/>
				<xsd:element ref="disable-priority"/>
				<xsd:element ref="wind-effect"/>
			</xsd:choice>
			<xsd:attribute name="name" type="xsd:string" use="required"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="per-vertex-shape">
		<xsd:annotation>
			<xsd:documentation>
				per-vertex-shape: there is no penetration tag inside per-vertex-shape.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:choice maxOccurs="unbounded">
				<xsd:element ref="margin"/>
				<xsd:element ref="tag"/>
				<xsd:element ref="shared"/>
				<xsd:element ref="no-collide-with-tag"/>
				<xsd:element ref="can-collide-with-tag"/>
				<xsd:element ref="no-collide-with-bone"/>
				<xsd:element ref="can-collide-with-bone"/>
				<xsd:element ref="weight-threshold"/>
				<xsd:element ref="disable-tag"/>
				<xsd:element ref="disable-priority"/>
				<xsd:element ref="wind-effect"/>
			</xsd:choice>
			<xsd:attribute name="name" type="xsd:string" use="required"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="shape">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="half-extend">
					<xsd:annotation>
						<xsd:documentation>
							For type box
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="margin" type="posFloat">
					<xsd:annotation>
						<xsd:documentation>
							For types box, hull and cylinder.
							Optional. Positive. If undefined, it's set to 0.
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="radius" type="posFloat">
					<xsd:annotation>
						<xsd:documentation>
							For types sphere, capsule and cylinder
							Optional. Positive. If undefined, it's set to 0.
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="height" type="posFloat">
					<xsd:annotation>
						<xsd:documentation>
							For types capsule and cylinder
							Optional. Positive. If undefined, it's set to 0.
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element ref="point">
					<xsd:annotation>
						<xsd:documentation>
							For type hull
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element ref="child">
					<xsd:annotation>
						<xsd:documentation>
							For type compound
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:choice>
			<xsd:attribute name="name" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						If type = "ref", then name is required and must be the name of a shape of another type.
						In other cases, name is not required, except if you want to be able to reference it from a shape of type "ref".
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="type" type="shapeType" use="required"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="stiffspring-constraint">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="minDistanceFactor"/>
				<xsd:element ref="maxDistanceFactor"/>
				<xsd:element ref="stiffness"/>
				<xsd:element ref="damping"/>
				<xsd:element ref="equilibrium"/>
			</xsd:choice>
			<xsd:attribute name="bodyA" type="xsd:string" use="required">
				<xsd:annotation>
					<xsd:documentation>
						bodyA is required and must contain a bone name. Bone declaration is optional, see the bone documentation.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="bodyB" type="xsd:string" use="required">
				<xsd:annotation>
					<xsd:documentation>
						bodyB is required and must contain a bone name. Bone declaration is optional, see the bone documentation.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="template" type="xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="stiffspring-constraint-default">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element ref="minDistanceFactor"/>
				<xsd:element ref="maxDistanceFactor"/>
				<xsd:element ref="stiffness"/>
				<xsd:element ref="damping"/>
				<xsd:element ref="equilibrium"/>
			</xsd:choice>
			<xsd:attribute name="name" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						The name of a stiffspring-constraint-default is optional. If it isn't set, "" is the name.
						As the xml is interpreted line by line, you can redefine the default so that it impacts the following stiffspring-constraints.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="extends" type="xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="system">
		<xsd:complexType>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element ref="bone"/>
				<xsd:element ref="bone-default"/>
				<xsd:element ref="conetwist-constraint"/>
				<xsd:element ref="conetwist-constraint-default"/>
				<xsd:element ref="constraint-group"/>
				<xsd:element ref="generic-constraint"/>
				<xsd:element ref="generic-constraint-default"/>
				<xsd:element ref="per-triangle-shape"/>
				<xsd:element ref="per-vertex-shape"/>
				<xsd:element ref="shape"/>
				<xsd:element ref="stiffspring-constraint"/>
				<xsd:element ref="stiffspring-constraint-default"/>
			</xsd:choice>
		</xsd:complexType>
		<xsd:key name="boneKey">
			<xsd:selector xpath="bone"/>
			<xsd:field xpath="@name"/>
		</xsd:key>
		<xsd:unique name="boneDefaultKey">
			<xsd:selector xpath="bone-default"/>
			<xsd:field xpath="@name"/>
		</xsd:unique>
		<xsd:keyref name="boneDefaultKeyInBoneTemplate" refer="boneDefaultKey">
			<xsd:selector xpath="bone"/>
			<xsd:field xpath="@template"/>
		</xsd:keyref>
		<xsd:keyref name="boneDefaultKeyInBoneExtends" refer="boneDefaultKey">
			<xsd:selector xpath="bone|bone-default"/>
			<xsd:field xpath="@extends"/>
		</xsd:keyref>
		<xsd:unique name="conetwistConstraintDefaultKey">
			<xsd:selector xpath="conetwist-constraint-default"/>
			<xsd:field xpath="@name"/>
		</xsd:unique>
		<xsd:keyref name="conetwistConstraintDefaultKeyInConetwistConstraint" refer="conetwistConstraintDefaultKey">
			<xsd:selector xpath="conetwist-constraint"/>
			<xsd:field xpath="@template"/>
		</xsd:keyref>
		<xsd:keyref name="conetwistConstraintDefaultKeyInConetwistConstraintTemplate" refer="conetwistConstraintDefaultKey">
			<xsd:selector xpath="conetwist-constraint-template"/>
			<xsd:field xpath="@extends"/>
		</xsd:keyref>
		<xsd:unique name="stiffspringConstraintDefaultKey">
			<xsd:selector xpath="stiffspring-constraint-default"/>
			<xsd:field xpath="@name"/>
		</xsd:unique>
		<xsd:keyref name="stiffspringConstraintDefaultKeyInStiffspringConstraint" refer="stiffspringConstraintDefaultKey">
			<xsd:selector xpath="stiffspring-constraint"/>
			<xsd:field xpath="@template"/>
		</xsd:keyref>
		<xsd:keyref name="stiffspringConstraintDefaultKeyInStiffspringConstraintTemplate" refer="stiffspringConstraintDefaultKey">
			<xsd:selector xpath="stiffspring-constraint-template"/>
			<xsd:field xpath="@extends"/>
		</xsd:keyref>
		<xsd:unique name="genericConstraintDefaultKey">
			<xsd:selector xpath="generic-constraint-default"/>
			<xsd:field xpath="@name"/>
		</xsd:unique>
		<xsd:keyref name="genericConstraintDefaultKeyInGenericConstraint" refer="genericConstraintDefaultKey">
			<xsd:selector xpath="generic-constraint"/>
			<xsd:field xpath="@template"/>
		</xsd:keyref>
		<xsd:keyref name="genericConstraintDefaultKeyInGenericConstraintTemplate" refer="genericConstraintDefaultKey">
			<xsd:selector xpath="generic-constraint-template"/>
			<xsd:field xpath="@extends"/>
		</xsd:keyref>
		<xsd:key name="per-triangle-shapeKey">
			<xsd:selector xpath="per-triangle-shape"/>
			<xsd:field xpath="@name"/>
		</xsd:key>
		<xsd:key name="per-vertex-shapeKey">
			<xsd:selector xpath="per-vertex-shape"/>
			<xsd:field xpath="@name"/>
		</xsd:key>
	</xsd:element>


	<!-- ############################################################ -->
	<!-- complexTypes -->
	<!-- ############################################################ -->

	<xsd:complexType name="vector3">
		<xsd:simpleContent>
			<xsd:extension base="xsd:string">
				<xsd:attribute name="x" type="xsd:float" use="required"/>
				<xsd:attribute name="y" type="xsd:float" use="required"/>
				<xsd:attribute name="z" type="xsd:float" use="required"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="limitedVector3">
		<xsd:simpleContent>
			<xsd:extension base="xsd:string">
				<xsd:attribute name="x" type="factor" use="required"/>
				<xsd:attribute name="y" type="factor" use="required"/>
				<xsd:attribute name="z" type="factor" use="required"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="quaternion">
		<xsd:simpleContent>
			<xsd:extension base="xsd:string">
				<xsd:attribute name="x" type="xsd:float" use="required"/>
				<xsd:attribute name="y" type="xsd:float" use="required"/>
				<xsd:attribute name="z" type="xsd:float" use="required"/>
				<xsd:attribute name="w" type="xsd:float" use="required"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="transform">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="basis" type="quaternion">
				<xsd:annotation>
					<xsd:documentation>
						This is a quaternion. If it's set with a length of zero, it will be set as Identity (0, 0, 0, 1). Rotational COM.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="basis-axis-angle">
				<xsd:annotation>
					<xsd:documentation>
					This is a transformation rotation with an angle around an axis defined by a vector. If the vector (x, y, z) is (0, 0, 0), it will be set as (1,0,0), and the angle will be set at 0 whatever its value. The length of the vector isn't important as it will be normalized. The angle is in radians.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:complexType>
					<xsd:simpleContent>
						<xsd:extension base="xsd:string">
							<xsd:attribute name="x" type="xsd:float" use="required"/>
							<xsd:attribute name="y" type="xsd:float" use="required"/>
							<xsd:attribute name="z" type="xsd:float" use="required"/>
							<xsd:attribute name="angle" type="xsd:float" use="required"/>
						</xsd:extension>
					</xsd:simpleContent>
				</xsd:complexType>
			</xsd:element>
			<xsd:element name="origin" type="vector3"/>
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="lerp">
		<xsd:all>
			<xsd:element name="translationLerp" type="xsd:float" minOccurs="0"/>
			<xsd:element name="rotationLerp" type="xsd:float" minOccurs="0"/>
		</xsd:all>
	</xsd:complexType>
</xsd:schema>